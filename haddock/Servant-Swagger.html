<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Servant.Swagger</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Servant-Swagger.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Servant-Swagger.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">servant-swagger-0.1.2: Generate Swagger specification for your servant API.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>Nickolay Kudasov &lt;nickolay@getshoptv.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Servant.Swagger</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">How to use this library</a><ul><li><a href="#g:2">Generate <code><code>Swagger</code></code></a></li><li><a href="#g:3">Annotate</a></li><li><a href="#g:4">Test</a></li><li><a href="#g:5">Serve</a></li></ul></li><li><a href="#g:6"><code><code>HasSwagger</code></code> class</a></li><li><a href="#g:7">Testing</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides means to generate and manipulate
 Swagger specification for servant APIs.</p><p>Swagger&#8482; is a project used to describe and document RESTful APIs.</p><p>The Swagger specification defines a set of files required to describe such an API.
 These files can then be used by the Swagger-UI project to display the API
 and Swagger-Codegen to generate clients in various languages.
 Additional utilities can also take advantage of the resulting files, such as testing tools.</p><p>For more information see <a href="http://swagger.io/">Swagger&#8482; documentation</a>.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> <a href="#t:HasSwagger">HasSwagger</a> api <span class="keyword">where</span><ul class="subs"><li><a href="#v:toSwagger">toSwagger</a> :: <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> api -&gt; Swagger</li></ul></li><li class="src short"><a href="#v:subOperations">subOperations</a> :: (<a href="Servant-Swagger-Internal-TypeLevel-API.html#t:IsSubAPI">IsSubAPI</a> sub api, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> sub) =&gt; <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> sub -&gt; <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> api -&gt; Traversal' Swagger Operation</li><li class="src short"><a href="#v:validateEveryToJSON">validateEveryToJSON</a> :: <span class="keyword">forall</span> proxy api. <a href="Servant-Swagger-Internal-TypeLevel-TMap.html#t:TMap">TMap</a> (<a href="Servant-Swagger-Internal-TypeLevel-Every.html#t:Every">Every</a> `[<a href="../base-4.8.2.0/Data-Typeable-Internal.html#t:Typeable">Typeable</a>, <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a>, Arbitrary, ToJSON, ToSchema]`) (<a href="Servant-Swagger-Internal-TypeLevel-API.html#t:BodyTypes">BodyTypes</a> JSON api) =&gt; proxy api -&gt; Spec</li></ul></div><div id="interface"><h1 id="g:1">How to use this library</h1><div class="doc"><p>This section explains how to use this library to generate Swagger specification,
 modify it and run automatic tests for a servant API.</p><p>For the purposes of this section we will use this servant API:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data User = User { name :: String, age :: Int } deriving (Show, Generic, Typeable)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>newtype UserId = UserId Integer deriving (Show, Generic, Typeable, ToJSON)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToJSON User
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToSchema User
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToSchema UserId
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToParamSchema UserId
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type GetUsers = Get '[JSON] [User]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type GetUser  = Capture &quot;user_id&quot; UserId :&gt; Get '[JSON] User
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type PostUser = ReqBody '[JSON] User :&gt; Post '[JSON] UserId
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type UserAPI  = GetUsers :&lt;|&gt; GetUser :&lt;|&gt; PostUser
</code></strong></pre><p>Here we define a user API with three endpoints. <code>GetUsers</code> endpoint returns a list of all users.
 <code>GetUser</code> returns a user given his<em>her ID. <code>PostUser</code> creates a new user and returns his</em>her ID.</p></div><h2 id="g:2">Generate <code><code>Swagger</code></code></h2><div class="doc"><p>In order to generate <code><code>Swagger</code></code> specification for a servant API, just use <code><code><a href="Servant-Swagger.html#v:toSwagger">toSwagger</a></code></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>encode $ toSwagger (Proxy :: Proxy UserAPI)
</code></strong>&quot;{\&quot;swagger\&quot;:\&quot;2.0\&quot;,\&quot;info\&quot;:{\&quot;version\&quot;:\&quot;\&quot;,\&quot;title\&quot;:\&quot;\&quot;},\&quot;definitions\&quot;:{\&quot;User\&quot;:{\&quot;required\&quot;:[\&quot;name\&quot;,\&quot;age\&quot;],\&quot;type\&quot;:\&quot;object\&quot;,\&quot;properties\&quot;:{\&quot;age\&quot;:{\&quot;maximum\&quot;:9223372036854775807,\&quot;minimum\&quot;:-9223372036854775808,\&quot;type\&quot;:\&quot;integer\&quot;},\&quot;name\&quot;:{\&quot;type\&quot;:\&quot;string\&quot;}}},\&quot;UserId\&quot;:{\&quot;type\&quot;:\&quot;integer\&quot;}},\&quot;paths\&quot;:{\&quot;/{user_id}\&quot;:{\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;404\&quot;:{\&quot;description\&quot;:\&quot;`user_id` not found\&quot;},\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;in\&quot;:\&quot;path\&quot;,\&quot;name\&quot;:\&quot;user_id\&quot;,\&quot;type\&quot;:\&quot;integer\&quot;}]}},\&quot;/\&quot;:{\&quot;post\&quot;:{\&quot;consumes\&quot;:[\&quot;application/json\&quot;],\&quot;responses\&quot;:{\&quot;400\&quot;:{\&quot;description\&quot;:\&quot;Invalid `body`\&quot;},\&quot;201\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/UserId\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;in\&quot;:\&quot;body\&quot;,\&quot;name\&quot;:\&quot;body\&quot;}]},\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;items\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;type\&quot;:\&quot;array\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;]}}}}&quot;
</pre><p>By default <code><code><a href="Servant-Swagger.html#v:toSwagger">toSwagger</a></code></code> will generate specification for all API routes, parameters, headers, responses and data schemas.</p><p>For some parameters it will also add 400 and/or 404 responses with a description mentioning parameter name.</p><p>Data schemas come from <code><code>ToParamSchema</code></code> and <code><code>ToSchema</code></code> classes.</p></div><h2 id="g:3">Annotate</h2><div class="doc"><p>While initially generated <code><code>Swagger</code></code> looks good, it lacks some information it can't get from a servant API.</p><p>We can add this information using field lenses from <code><a href="Data-Swagger.html">Data.Swagger</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>encode $ toSwagger (Proxy :: Proxy UserAPI)
  &amp; info.title        .~ &quot;User API&quot;
  &amp; info.version      .~ &quot;1.0&quot;
  &amp; info.description  ?~ &quot;This is an API for the Users service&quot;
  &amp; info.license      ?~ &quot;MIT&quot;
  &amp; host              ?~ &quot;example.com&quot;
:}
&quot;{\&quot;swagger\&quot;:\&quot;2.0\&quot;,\&quot;host\&quot;:\&quot;example.com\&quot;,\&quot;info\&quot;:{\&quot;version\&quot;:\&quot;1.0\&quot;,\&quot;title\&quot;:\&quot;User API\&quot;,\&quot;license\&quot;:{\&quot;name\&quot;:\&quot;MIT\&quot;},\&quot;description\&quot;:\&quot;This is an API for the Users service\&quot;},\&quot;definitions\&quot;:{\&quot;User\&quot;:{\&quot;required\&quot;:[\&quot;name\&quot;,\&quot;age\&quot;],\&quot;type\&quot;:\&quot;object\&quot;,\&quot;properties\&quot;:{\&quot;age\&quot;:{\&quot;maximum\&quot;:9223372036854775807,\&quot;minimum\&quot;:-9223372036854775808,\&quot;type\&quot;:\&quot;integer\&quot;},\&quot;name\&quot;:{\&quot;type\&quot;:\&quot;string\&quot;}}},\&quot;UserId\&quot;:{\&quot;type\&quot;:\&quot;integer\&quot;}},\&quot;paths\&quot;:{\&quot;/{user_id}\&quot;:{\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;404\&quot;:{\&quot;description\&quot;:\&quot;`user_id` not found\&quot;},\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;in\&quot;:\&quot;path\&quot;,\&quot;name\&quot;:\&quot;user_id\&quot;,\&quot;type\&quot;:\&quot;integer\&quot;}]}},\&quot;/\&quot;:{\&quot;post\&quot;:{\&quot;consumes\&quot;:[\&quot;application/json\&quot;],\&quot;responses\&quot;:{\&quot;400\&quot;:{\&quot;description\&quot;:\&quot;Invalid `body`\&quot;},\&quot;201\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/UserId\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;in\&quot;:\&quot;body\&quot;,\&quot;name\&quot;:\&quot;body\&quot;}]},\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;items\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;type\&quot;:\&quot;array\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;]}}}}&quot;
</pre><p>It is also useful to annotate or modify certain endpoints.
 <code><code><a href="Servant-Swagger.html#v:subOperations">subOperations</a></code></code> provides a convenient way to zoom into a part of an API.</p><p><code><code><a href="Servant-Swagger.html#v:subOperations">subOperations</a></code> sub api</code> traverses all operations of the <code>api</code> which are also present in <code>sub</code>.
 Furthermore, <code>sub</code> is required to be an exact sub API of @api. Otherwise it will not typecheck.</p><p><code><a href="Data-Swagger-Operation.html">Data.Swagger.Operation</a></code> provides some useful helpers that can be used with <code><code><a href="Servant-Swagger.html#v:subOperations">subOperations</a></code></code>.
 One example is applying tags to certain endpoints:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let getOps  = subOperations (Proxy :: Proxy (GetUsers :&lt;|&gt; GetUser)) (Proxy :: Proxy UserAPI)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let postOps = subOperations (Proxy :: Proxy PostUser) (Proxy :: Proxy UserAPI)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:{
</code></strong>encode $ toSwagger (Proxy :: Proxy UserAPI)
  &amp; applyTagsFor getOps  [&quot;get&quot;  &amp; description ?~ &quot;GET operations&quot;]
  &amp; applyTagsFor postOps [&quot;post&quot; &amp; description ?~ &quot;POST operations&quot;]
:}
&quot;{\&quot;swagger\&quot;:\&quot;2.0\&quot;,\&quot;info\&quot;:{\&quot;version\&quot;:\&quot;\&quot;,\&quot;title\&quot;:\&quot;\&quot;},\&quot;definitions\&quot;:{\&quot;User\&quot;:{\&quot;required\&quot;:[\&quot;name\&quot;,\&quot;age\&quot;],\&quot;type\&quot;:\&quot;object\&quot;,\&quot;properties\&quot;:{\&quot;age\&quot;:{\&quot;maximum\&quot;:9223372036854775807,\&quot;minimum\&quot;:-9223372036854775808,\&quot;type\&quot;:\&quot;integer\&quot;},\&quot;name\&quot;:{\&quot;type\&quot;:\&quot;string\&quot;}}},\&quot;UserId\&quot;:{\&quot;type\&quot;:\&quot;integer\&quot;}},\&quot;paths\&quot;:{\&quot;/{user_id}\&quot;:{\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;404\&quot;:{\&quot;description\&quot;:\&quot;`user_id` not found\&quot;},\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;in\&quot;:\&quot;path\&quot;,\&quot;name\&quot;:\&quot;user_id\&quot;,\&quot;type\&quot;:\&quot;integer\&quot;}],\&quot;tags\&quot;:[\&quot;get\&quot;]}},\&quot;/\&quot;:{\&quot;post\&quot;:{\&quot;consumes\&quot;:[\&quot;application/json\&quot;],\&quot;responses\&quot;:{\&quot;400\&quot;:{\&quot;description\&quot;:\&quot;Invalid `body`\&quot;},\&quot;201\&quot;:{\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/UserId\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;parameters\&quot;:[{\&quot;required\&quot;:true,\&quot;schema\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;in\&quot;:\&quot;body\&quot;,\&quot;name\&quot;:\&quot;body\&quot;}],\&quot;tags\&quot;:[\&quot;post\&quot;]},\&quot;get\&quot;:{\&quot;responses\&quot;:{\&quot;200\&quot;:{\&quot;schema\&quot;:{\&quot;items\&quot;:{\&quot;$ref\&quot;:\&quot;#/definitions/User\&quot;},\&quot;type\&quot;:\&quot;array\&quot;},\&quot;description\&quot;:\&quot;\&quot;}},\&quot;produces\&quot;:[\&quot;application/json\&quot;],\&quot;tags\&quot;:[\&quot;get\&quot;]}}},\&quot;tags\&quot;:[{\&quot;name\&quot;:\&quot;get\&quot;,\&quot;description\&quot;:\&quot;GET operations\&quot;},{\&quot;name\&quot;:\&quot;post\&quot;,\&quot;description\&quot;:\&quot;POST operations\&quot;}]}&quot;
</pre><p>This applies <code>&quot;get&quot;</code> tag to the <code>GET</code> endpoints and <code>&quot;post&quot;</code> tag to the <code><a href="POST.html">POST</a></code> endpoint of the User API.</p></div><h2 id="g:4">Test</h2><div class="doc"><p>Automatic generation of data schemas uses <code><code>ToSchema</code></code> instances for the types
 used in a servant API. But to encode/decode actual data servant uses different classes.
 For instance in <code>UserAPI</code> <code>User</code> is always encoded/decoded using <code><code>ToJSON</code></code> and <code><code>FromJSON</code></code> instances.</p><p>To be sure your Haskell server/client handles data properly you need to check
 that <code><code>ToJSON</code></code> instance always generates values that satisfy schema produced
 by <code><code>ToSchema</code></code> instance.</p><p>With <code><code><a href="Servant-Swagger.html#v:validateEveryToJSON">validateEveryToJSON</a></code></code> it is possible to test all those instances automatically,
 without having to write down every type:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance Arbitrary UserId where arbitrary = UserId &lt;$&gt; arbitrary
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hspec $ validateEveryToJSON (Proxy :: Proxy UserAPI)
</code></strong>
[User]
User
UserId

Finished in ... seconds
3 examples, 0 failures
</pre><p>Although servant is great chances are that your API clients don't use Haskell.
 In many cases <code>swagger.json</code> serves as a specification, not a Haskell type.</p><p>In this cases it is a good idea to store generated and annotated <code><code>Swagger</code></code> in a <code>swagger.json</code> file
 under a version control system (such as Git, Subversion, Mercurial, etc.).
 It is also recommended to version API based on changes to the <code>swagger.json</code> rather than changes
 to the Haskell API.</p><p>See <a href="example/test/TodoSpec.hs">TodoSpec.hs</a> for an example of a complete test suite for a swagger specification.</p></div><h2 id="g:5">Serve</h2><div class="doc"><p>If you're implementing a server for an API, you might also want to serve its <code><code>Swagger</code></code> specification.</p><p>See <a href="example/src/Todo.hs">Todo.hs</a> for an example of a server.</p></div><h1 id="g:6"><code><code><a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a></code></code> class</h1><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:HasSwagger" class="def">HasSwagger</a> api <span class="keyword">where</span> <a href="src/Servant-Swagger-Internal.html#HasSwagger" class="link">Source</a></p><div class="doc"><p>Generate a Swagger specification for a servant API.</p><p>To generate Swagger specification, your data types need
 <code><code>ToParamSchema</code></code> and/or <code><code>ToSchema</code></code> instances.</p><p><code><code>ToParamSchema</code></code> is used for <code><code>Capture</code></code>, <code><code>QueryParam</code></code> and <code><code>Header</code></code>.
 <code><code>ToSchema</code></code> is used for <code><code>ReqBody</code></code> and response data types.</p><p>You can easily derive those instances via <code>Generic</code>.
 For more information, refer to <a href="http://hackage.haskell.org/package/swagger2/docs/Data-Swagger.html">swagger2 documentation</a>.</p><p>Example:</p><pre>newtype Username = Username String deriving (Generic, ToText)

instance ToParamSchema Username

data User = User
  { username :: Username
  , fullname :: String
  } deriving (Generic)

instance ToJSON User
instance ToSchema User

type MyAPI = QueryParam &quot;username&quot; Username :&gt; Get '[JSON] User

mySwagger :: Swagger
mySwagger = toSwagger (Proxy :: Proxy MyAPI)
</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toSwagger" class="def">toSwagger</a> :: <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> api -&gt; Swagger <a href="src/Servant-Swagger-Internal.html#toSwagger" class="link">Source</a></p><div class="doc"><p>Generate a Swagger specification for a servant API.</p></div></div><div class="subs instances"><p id="control.i:HasSwagger" class="caption collapser" onclick="toggleSection('i:HasSwagger')">Instances</p><div id="section.i:HasSwagger" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * Raw</span> <a href="src/Servant-Swagger-Internal.html#line-63" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Put cs ())</span> <a href="src/Servant-Swagger-Internal.html#line-183" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger-Internal.html#t:AllToResponseHeader">AllToResponseHeader</a> [*] hs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Put cs (Headers hs a))</span> <a href="src/Servant-Swagger-Internal.html#line-180" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Put cs a)</span> <a href="src/Servant-Swagger-Internal.html#line-177" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Post cs ())</span> <a href="src/Servant-Swagger-Internal.html#line-196" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger-Internal.html#t:AllToResponseHeader">AllToResponseHeader</a> [*] hs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Post cs (Headers hs a))</span> <a href="src/Servant-Swagger-Internal.html#line-193" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Post cs a)</span> <a href="src/Servant-Swagger-Internal.html#line-190" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Patch cs ())</span> <a href="src/Servant-Swagger-Internal.html#line-170" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger-Internal.html#t:AllToResponseHeader">AllToResponseHeader</a> [*] hs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Patch cs (Headers hs a))</span> <a href="src/Servant-Swagger-Internal.html#line-167" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Patch cs a)</span> <a href="src/Servant-Swagger-Internal.html#line-164" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Get cs ())</span> <a href="src/Servant-Swagger-Internal.html#line-157" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger-Internal.html#t:AllToResponseHeader">AllToResponseHeader</a> [*] hs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Get cs (Headers hs a))</span> <a href="src/Servant-Swagger-Internal.html#line-154" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Get cs a)</span> <a href="src/Servant-Swagger-Internal.html#line-151" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Delete cs ())</span> <a href="src/Servant-Swagger-Internal.html#line-144" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger-Internal.html#t:AllToResponseHeader">AllToResponseHeader</a> [*] hs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Delete cs (Headers hs a))</span> <a href="src/Servant-Swagger-Internal.html#line-141" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * (Delete cs a)</span> <a href="src/Servant-Swagger-Internal.html#line-138" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * a, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * b) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&lt;|&gt;) a b)</span> <a href="src/Servant-Swagger-Internal.html#line-199" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(ToSchema a, <a href="Servant-Swagger-Internal.html#t:AllAccept">AllAccept</a> [*] cs, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (ReqBody * cs a) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-275" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, ToParamSchema a, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (Header sym a) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-263" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (QueryFlag sym) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-249" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, ToParamSchema a, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (QueryParams * sym a) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-235" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, ToParamSchema a, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (QueryParam * sym a) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-223" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, ToParamSchema a, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) * k (Capture * sym a) sub)</span> <a href="src/Servant-Swagger-Internal.html#line-207" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left">(<a href="../base-4.8.2.0/GHC-TypeLits.html#t:KnownSymbol">KnownSymbol</a> sym, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> k sub) =&gt; <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> * ((:&gt;) <a href="../base-4.8.2.0/GHC-TypeLits.html#t:Symbol">Symbol</a> k sym sub)</span> <a href="src/Servant-Swagger-Internal.html#line-202" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:subOperations" class="def">subOperations</a> :: (<a href="Servant-Swagger-Internal-TypeLevel-API.html#t:IsSubAPI">IsSubAPI</a> sub api, <a href="Servant-Swagger.html#t:HasSwagger">HasSwagger</a> sub) =&gt; <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> sub -&gt; <a href="../base-4.8.2.0/Data-Proxy.html#t:Proxy">Proxy</a> api -&gt; Traversal' Swagger Operation <a href="src/Servant-Swagger-Internal.html#subOperations" class="link">Source</a></p><div class="doc"><p>All operations of sub API.
 This is similar to <code><code>operationsOf</code></code> but ensures that operations
 indeed belong to the API at compile time.</p></div></div><h1 id="g:7">Testing</h1><div class="top"><p class="src"><a name="v:validateEveryToJSON" class="def">validateEveryToJSON</a> :: <span class="keyword">forall</span> proxy api. <a href="Servant-Swagger-Internal-TypeLevel-TMap.html#t:TMap">TMap</a> (<a href="Servant-Swagger-Internal-TypeLevel-Every.html#t:Every">Every</a> `[<a href="../base-4.8.2.0/Data-Typeable-Internal.html#t:Typeable">Typeable</a>, <a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a>, Arbitrary, ToJSON, ToSchema]`) (<a href="Servant-Swagger-Internal-TypeLevel-API.html#t:BodyTypes">BodyTypes</a> JSON api) =&gt; proxy api -&gt; Spec <a href="src/Servant-Swagger-Internal-Test.html#validateEveryToJSON" class="link">Source</a></p><div class="doc"><p>Verify that every type used with <code><code>JSON</code></code> content type in a servant API
 has compatible <code><code>ToJSON</code></code> and <code><code>ToSchema</code></code> instances using <code><code>validateToJSON</code></code>.</p><p><code><code><a href="Servant-Swagger.html#v:validateEveryToJSON">validateEveryToJSON</a></code></code> will produce one <code><code>prop</code></code> specification for every type in the API.
 Each type only gets one test, even if it occurs multiple times in the API.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToJSON User
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToSchema User
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToSchema UserId
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type UserAPI = (Capture &quot;user_id&quot; UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hspec $ context &quot;ToJSON matches ToSchema&quot; $ validateEveryToJSON (Proxy :: Proxy UserAPI)
</code></strong>
ToJSON matches ToSchema
  User
  UserId

Finished in ... seconds
2 examples, 0 failures
</pre><p>For the test to compile all body types should have the following instances:</p><ul><li><code><code>ToJSON</code></code> and <code><code>ToSchema</code></code> are used to perform the validation;</li><li><code><code><a href="../base-4.8.2.0/Data-Typeable-Internal.html#t:Typeable">Typeable</a></code></code> is used to name the test for each type;</li><li><code><code><a href="../base-4.8.2.0/Text-Show.html#t:Show">Show</a></code></code> is used to display value for which <code><code>ToJSON</code></code> does not satisfy <code><code>ToSchema</code></code>.</li><li><code><code>Arbitrary</code></code> is used to arbitrarily generate values.</li></ul><p>If any of the instances is missing, you'll get a descriptive type error:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToJSON Contact
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>instance ToSchema Contact
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>type ContactAPI = Get '[JSON] Contact
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
</code></strong>...
    No instance for (Arbitrary Contact)
      arising from a use of &#8216;validateEveryToJSON&#8217;
...
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>