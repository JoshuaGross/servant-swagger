-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate Swagger specification for your servant API.
--   
--   Please see README.md
@package servant-swagger
@version 0.1.2

module Servant.Swagger.Internal.TypeLevel.TMap

-- | Map a list of constrained types to a list of values.
--   
--   <pre>
--   &gt;&gt;&gt; tmap (Proxy :: Proxy KnownSymbol) symbolVal (Proxy :: Proxy ["hello", "world"])
--   ["hello","world"]
--   </pre>
class TMap (q :: k -> Constraint) (xs :: [k])
tmap :: TMap q xs => p q -> (forall x p'. q x => p' x -> a) -> p'' xs -> [a]
instance forall (k :: BOX) (q :: k -> GHC.Prim.Constraint). Servant.Swagger.Internal.TypeLevel.TMap.TMap q '[]
instance forall (k :: BOX) (q :: k -> GHC.Prim.Constraint) (x :: k) (xs :: [k]). (q x, Servant.Swagger.Internal.TypeLevel.TMap.TMap q xs) => Servant.Swagger.Internal.TypeLevel.TMap.TMap q (x : xs)

module Servant.Swagger.Internal.TypeLevel.Every

-- | Apply multiple constraint constructors to a type.
--   
--   <pre>
--   EveryTF '[Show, Read] a ~ (Show a, Read a)
--   </pre>
--   
--   Note that since this is a type family, you have to alway fully apply
--   <tt><a>EveryTF</a></tt>.
--   
--   For partial application of multiple constraint constructors see
--   <tt><a>Every</a></tt>.

-- | Apply multiple constraint constructors to a type as a class.
--   
--   This is different from <tt><a>EveryTF</a></tt> in that it allows
--   partial application.
class EveryTF cs x => Every (cs :: [* -> Constraint]) (x :: *)

-- | Like <tt><a>tmap</a></tt>, but uses <tt><a>Every</a></tt> for multiple
--   constraints.
--   
--   <pre>
--   &gt;&gt;&gt; let zero :: forall p a. (Show a, Num a) =&gt; p a -&gt; String; zero _ = show (0 :: a)
--   
--   &gt;&gt;&gt; tmapEvery (Proxy :: Proxy [Show, Num]) zero (Proxy :: Proxy [Int, Float])
--   ["0","0.0"]
--   </pre>
tmapEvery :: (TMap (Every cs) xs) => p cs -> (forall x p'. EveryTF cs x => p' x -> a) -> p'' xs -> [a]
instance Servant.Swagger.Internal.TypeLevel.Every.Every '[] x
instance (c x, Servant.Swagger.Internal.TypeLevel.Every.Every cs x) => Servant.Swagger.Internal.TypeLevel.Every.Every (c : cs) x

module Servant.Swagger.Internal.TypeLevel.API

-- | Build a list of endpoints from an API.

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.

-- | Check that every element of <tt>xs</tt> is an endpoint of
--   <tt>api</tt>.

-- | Apply <tt>(e :&gt;)</tt> to every API in <tt>xs</tt>.

-- | Append two type-level lists.

-- | Check whether a type is a member of a list of types. This is a
--   type-level analogue of <tt><a>elem</a></tt>.

-- | <tt><a>AddBodyType</a> c cs a as</tt> adds type <tt>a</tt> to the list
--   <tt>as</tt> only if <tt>c</tt> is in <tt>cs</tt> and <tt>a</tt> is not
--   in <tt>as</tt>. This allows to build a list of unique body types.
type AddBodyType c cs a as = If (Elem c cs) (Insert a as) as

-- | Insert type <tt>x</tt> into a type list <tt>xs</tt> only if it is not
--   already there.
type Insert x xs = If (Elem x xs) xs (x : xs)

-- | Merge two lists, ignoring any type in <tt>xs</tt> which occurs also in
--   <tt>ys</tt>.

-- | Extract a list of unique "body" types for a specific content-type from
--   a servant API.

module Servant.Swagger.Internal.TypeLevel


-- | Useful type families for servant APIs.
module Servant.Swagger.TypeLevel

-- | Check whether <tt>sub</tt> is a sub API of <tt>api</tt>.

-- | Build a list of endpoints from an API.

-- | Extract a list of unique "body" types for a specific content-type from
--   a servant API.

module Servant.Swagger.Internal.Test

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User
--     UserId
--   
--   Finished in ... seconds
--   2 examples, 0 failures
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--       No instance for (Arbitrary Contact)
--         arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: TMap (Every '[Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec

-- | Construct property tests for each type in a list. The name for each
--   property is the name of the corresponding type.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--    hspec $
--      context "read . show == id" $
--        props
--          (Proxy :: Proxy [Eq, Show, Read])
--          (\x -&gt; read (show x) == x)
--          (Proxy :: Proxy [Bool, Int, String])
--   :}
--   
--   read . show == id
--     Bool
--     Int
--     [Char]
--   
--   Finished in ... seconds
--   3 examples, 0 failures
--   </pre>
props :: TMap (Every (Typeable : (Show : (Arbitrary : cs)))) xs => p cs -> (forall x. EveryTF cs x => x -> Bool) -> p'' xs -> Spec


-- | Automatic tests for servant API against Swagger spec.
module Servant.Swagger.Test

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User
--     UserId
--   
--   Finished in ... seconds
--   2 examples, 0 failures
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--       No instance for (Arbitrary Contact)
--         arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: TMap (Every '[Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec

module Servant.Swagger.Internal

-- | Generate a Swagger specification for a servant API.
--   
--   To generate Swagger specification, your data types need
--   <tt><a>ToParamSchema</a></tt> and/or <tt><a>ToSchema</a></tt>
--   instances.
--   
--   <tt><a>ToParamSchema</a></tt> is used for <tt><a>Capture</a></tt>,
--   <tt><a>QueryParam</a></tt> and <tt><a>Header</a></tt>.
--   <tt><a>ToSchema</a></tt> is used for <tt><a>ReqBody</a></tt> and
--   response data types.
--   
--   You can easily derive those instances via <tt>Generic</tt>. For more
--   information, refer to <a>swagger2 documentation</a>.
--   
--   Example:
--   
--   <pre>
--   newtype Username = Username String deriving (Generic, ToText)
--   
--   instance ToParamSchema Username
--   
--   data User = User
--     { username :: Username
--     , fullname :: String
--     } deriving (Generic)
--   
--   instance ToJSON User
--   instance ToSchema User
--   
--   type MyAPI = QueryParam "username" Username :&gt; Get '[JSON] User
--   
--   mySwagger :: Swagger
--   mySwagger = toSwagger (Proxy :: Proxy MyAPI)
--   </pre>
class HasSwagger api

-- | Generate a Swagger specification for a servant API.
toSwagger :: HasSwagger api => Proxy api -> Swagger

-- | All operations of sub API. This is similar to
--   <tt><a>operationsOf</a></tt> but ensures that operations indeed belong
--   to the API at compile time.
subOperations :: (IsSubAPI sub api, HasSwagger sub) => Proxy sub -> Proxy api -> Traversal' Swagger Operation
mkEndpoint :: (ToSchema a, AllAccept cs, AllToResponseHeader hs) => FilePath -> Lens' PathItem (Maybe Operation) -> HttpStatusCode -> proxy (_verb cs (Headers hs a)) -> Swagger
noContentEndpoint :: (AllAccept cs) => FilePath -> Lens' PathItem (Maybe Operation) -> proxy (verb cs ()) -> Swagger
mkEndpointWithSchemaRef :: (AllAccept cs, AllToResponseHeader hs) => Maybe (Referenced Schema) -> FilePath -> Lens' PathItem (Maybe Operation) -> HttpStatusCode -> proxy (verb cs (Headers hs a)) -> Swagger

-- | Add parameter to every operation in the spec.
addParam :: Param -> Swagger -> Swagger

-- | Add accepted content types to every operation in the spec.
addConsumes :: [MediaType] -> Swagger -> Swagger

-- | Format given text as inline code in Markdown.
markdownCode :: Text -> Text
addDefaultResponse404 :: ParamName -> Swagger -> Swagger
addDefaultResponse400 :: ParamName -> Swagger -> Swagger
class AllAccept cs
allContentType :: AllAccept cs => Proxy cs -> [MediaType]
class ToResponseHeader h
toResponseHeader :: ToResponseHeader h => Proxy h -> (HeaderName, Header)
class AllToResponseHeader hs
toAllResponseHeaders :: AllToResponseHeader hs => Proxy hs -> HashMap HeaderName Header
instance Servant.Swagger.Internal.HasSwagger Servant.API.Raw.Raw
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Delete.Delete cs a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Delete.Delete cs (Servant.API.ResponseHeaders.Headers hs a))
instance Servant.Swagger.Internal.AllAccept cs => Servant.Swagger.Internal.HasSwagger (Servant.API.Delete.Delete cs ())
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Get.Get cs a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Get.Get cs (Servant.API.ResponseHeaders.Headers hs a))
instance Servant.Swagger.Internal.AllAccept cs => Servant.Swagger.Internal.HasSwagger (Servant.API.Get.Get cs ())
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Patch.Patch cs a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Patch.Patch cs (Servant.API.ResponseHeaders.Headers hs a))
instance Servant.Swagger.Internal.AllAccept cs => Servant.Swagger.Internal.HasSwagger (Servant.API.Patch.Patch cs ())
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Put.Put cs a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Put.Put cs (Servant.API.ResponseHeaders.Headers hs a))
instance Servant.Swagger.Internal.AllAccept cs => Servant.Swagger.Internal.HasSwagger (Servant.API.Put.Put cs ())
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Post.Post cs a)
instance (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.HasSwagger (Servant.API.Post.Post cs (Servant.API.ResponseHeaders.Headers hs a))
instance Servant.Swagger.Internal.AllAccept cs => Servant.Swagger.Internal.HasSwagger (Servant.API.Post.Post cs ())
instance (Servant.Swagger.Internal.HasSwagger a, Servant.Swagger.Internal.HasSwagger b) => Servant.Swagger.Internal.HasSwagger (a Servant.API.Alternative.:<|> b)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) (sub :: k). (GHC.TypeLits.KnownSymbol sym, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (sym Servant.API.Sub.:> sub)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) a (sub :: k). (GHC.TypeLits.KnownSymbol sym, Data.Swagger.Internal.ParamSchema.ToParamSchema a, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.Capture.Capture sym a Servant.API.Sub.:> sub)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) a (sub :: k). (GHC.TypeLits.KnownSymbol sym, Data.Swagger.Internal.ParamSchema.ToParamSchema a, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.QueryParam.QueryParam sym a Servant.API.Sub.:> sub)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) a (sub :: k). (GHC.TypeLits.KnownSymbol sym, Data.Swagger.Internal.ParamSchema.ToParamSchema a, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.QueryParam.QueryParams sym a Servant.API.Sub.:> sub)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) (sub :: k). (GHC.TypeLits.KnownSymbol sym, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> sub)
instance forall (k :: BOX) (sym :: GHC.TypeLits.Symbol) a (sub :: k). (GHC.TypeLits.KnownSymbol sym, Data.Swagger.Internal.ParamSchema.ToParamSchema a, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.Header.Header sym a Servant.API.Sub.:> sub)
instance forall (k :: BOX) (cs :: [*]) a (sub :: k). (Data.Swagger.Internal.Schema.ToSchema a, Servant.Swagger.Internal.AllAccept cs, Servant.Swagger.Internal.HasSwagger sub) => Servant.Swagger.Internal.HasSwagger (Servant.API.ReqBody.ReqBody cs a Servant.API.Sub.:> sub)
instance Servant.Swagger.Internal.AllAccept '[]
instance forall (k :: BOX) (c :: k) (cs :: [k]). (Servant.API.ContentTypes.Accept c, Servant.Swagger.Internal.AllAccept cs) => Servant.Swagger.Internal.AllAccept (c : cs)
instance (GHC.TypeLits.KnownSymbol sym, Data.Swagger.Internal.ParamSchema.ToParamSchema a) => Servant.Swagger.Internal.ToResponseHeader (Servant.API.Header.Header sym a)
instance Servant.Swagger.Internal.AllToResponseHeader '[]
instance forall (k :: BOX) (h :: k) (hs :: [k]). (Servant.Swagger.Internal.ToResponseHeader h, Servant.Swagger.Internal.AllToResponseHeader hs) => Servant.Swagger.Internal.AllToResponseHeader (h : hs)
instance Servant.Swagger.Internal.AllToResponseHeader hs => Servant.Swagger.Internal.AllToResponseHeader (Servant.API.ResponseHeaders.HList hs)


-- | This module provides means to generate and manipulate Swagger
--   specification for servant APIs.
--   
--   Swagger™ is a project used to describe and document RESTful APIs.
--   
--   The Swagger specification defines a set of files required to describe
--   such an API. These files can then be used by the Swagger-UI project to
--   display the API and Swagger-Codegen to generate clients in various
--   languages. Additional utilities can also take advantage of the
--   resulting files, such as testing tools.
--   
--   For more information see <a>Swagger™ documentation</a>.
module Servant.Swagger

-- | Generate a Swagger specification for a servant API.
--   
--   To generate Swagger specification, your data types need
--   <tt><a>ToParamSchema</a></tt> and/or <tt><a>ToSchema</a></tt>
--   instances.
--   
--   <tt><a>ToParamSchema</a></tt> is used for <tt><a>Capture</a></tt>,
--   <tt><a>QueryParam</a></tt> and <tt><a>Header</a></tt>.
--   <tt><a>ToSchema</a></tt> is used for <tt><a>ReqBody</a></tt> and
--   response data types.
--   
--   You can easily derive those instances via <tt>Generic</tt>. For more
--   information, refer to <a>swagger2 documentation</a>.
--   
--   Example:
--   
--   <pre>
--   newtype Username = Username String deriving (Generic, ToText)
--   
--   instance ToParamSchema Username
--   
--   data User = User
--     { username :: Username
--     , fullname :: String
--     } deriving (Generic)
--   
--   instance ToJSON User
--   instance ToSchema User
--   
--   type MyAPI = QueryParam "username" Username :&gt; Get '[JSON] User
--   
--   mySwagger :: Swagger
--   mySwagger = toSwagger (Proxy :: Proxy MyAPI)
--   </pre>
class HasSwagger api

-- | Generate a Swagger specification for a servant API.
toSwagger :: HasSwagger api => Proxy api -> Swagger

-- | All operations of sub API. This is similar to
--   <tt><a>operationsOf</a></tt> but ensures that operations indeed belong
--   to the API at compile time.
subOperations :: (IsSubAPI sub api, HasSwagger sub) => Proxy sub -> Proxy api -> Traversal' Swagger Operation

-- | Verify that every type used with <tt><a>JSON</a></tt> content type in
--   a servant API has compatible <tt><a>ToJSON</a></tt> and
--   <tt><a>ToSchema</a></tt> instances using
--   <tt><a>validateToJSON</a></tt>.
--   
--   <tt><a>validateEveryToJSON</a></tt> will produce one
--   <tt><a>prop</a></tt> specification for every type in the API. Each
--   type only gets one test, even if it occurs multiple times in the API.
--   
--   <pre>
--   &gt;&gt;&gt; data User = User { name :: String, age :: Maybe Int } deriving (Show, Generic, Typeable)
--   
--   &gt;&gt;&gt; newtype UserId = UserId String deriving (Show, Generic, Typeable, ToJSON, Arbitrary)
--   
--   &gt;&gt;&gt; instance ToJSON User
--   
--   &gt;&gt;&gt; instance ToSchema User
--   
--   &gt;&gt;&gt; instance ToSchema UserId
--   
--   &gt;&gt;&gt; instance Arbitrary User where arbitrary = User &lt;$&gt; arbitrary &lt;*&gt; arbitrary
--   
--   &gt;&gt;&gt; type UserAPI = (Capture "user_id" UserId :&gt; Get '[JSON] User) :&lt;|&gt; (ReqBody '[JSON] User :&gt; Post '[JSON] UserId)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hspec $ context "ToJSON matches ToSchema" $ validateEveryToJSON (Proxy :: Proxy UserAPI)
--   
--   ToJSON matches ToSchema
--     User
--     UserId
--   
--   Finished in ... seconds
--   2 examples, 0 failures
--   </pre>
--   
--   For the test to compile all body types should have the following
--   instances:
--   
--   <ul>
--   <li><tt><a>ToJSON</a></tt> and <tt><a>ToSchema</a></tt> are used to
--   perform the validation;</li>
--   <li><tt><a>Typeable</a></tt> is used to name the test for each
--   type;</li>
--   <li><tt><a>Show</a></tt> is used to display value for which
--   <tt><a>ToJSON</a></tt> does not satisfy <tt><a>ToSchema</a></tt>.</li>
--   <li><tt><a>Arbitrary</a></tt> is used to arbitrarily generate
--   values.</li>
--   </ul>
--   
--   If any of the instances is missing, you'll get a descriptive type
--   error:
--   
--   <pre>
--   &gt;&gt;&gt; data Contact = Contact { fullname :: String, phone :: Integer } deriving (Show, Generic)
--   
--   &gt;&gt;&gt; instance ToJSON Contact
--   
--   &gt;&gt;&gt; instance ToSchema Contact
--   
--   &gt;&gt;&gt; type ContactAPI = Get '[JSON] Contact
--   
--   &gt;&gt;&gt; hspec $ validateEveryToJSON (Proxy :: Proxy ContactAPI)
--   ...
--       No instance for (Arbitrary Contact)
--         arising from a use of ‘validateEveryToJSON’
--   ...
--   </pre>
validateEveryToJSON :: TMap (Every '[Typeable, Show, Arbitrary, ToJSON, ToSchema]) (BodyTypes JSON api) => proxy api -> Spec
